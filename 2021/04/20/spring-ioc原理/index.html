<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.xulixuli.ltd","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="简介：介绍Spring IOC 的实现原理以及IOC容器的启动流程。 关键词：Spring IOC；IOC原理；IOC源码；IOC启动；">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring IOC:实现原理">
<meta property="og:url" content="https://www.xulixuli.ltd/2021/04/20/spring-ioc%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="阿旭的博客">
<meta property="og:description" content="简介：介绍Spring IOC 的实现原理以及IOC容器的启动流程。 关键词：Spring IOC；IOC原理；IOC源码；IOC启动；">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2192701-40bdc919b96905bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2192701-fb440cb3f5b7a5ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1001/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2192701-f5913afea471c32c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2192701-7cafa9f49fd0007e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/332/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2192701-b704c5641b36c6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1066/format/webp">
<meta property="article:published_time" content="2021-04-20T15:27:33.000Z">
<meta property="article:modified_time" content="2022-08-20T15:58:37.525Z">
<meta property="article:author" content="阿旭">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2192701-40bdc919b96905bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp">


<link rel="canonical" href="https://www.xulixuli.ltd/2021/04/20/spring-ioc%E5%8E%9F%E7%90%86/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>Spring IOC:实现原理 | 阿旭的博客</title>
  

  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?42479d2c22aec2093e58c73f78855424";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">阿旭的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Good good study, day day up.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-主页"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>主页</a></li>
        <li class="menu-item menu-item-所有文章"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>所有文章</a></li>
        <li class="menu-item menu-item-文章标签"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>文章标签</a></li>
        <li class="menu-item menu-item-文章分类"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>文章分类</a></li>
        <li class="menu-item menu-item-校园の猫"><a href="/miaomiao/" rel="section"><i class="fas fa-cat fa-fw"></i>校园の猫</a></li>
        <li class="menu-item menu-item-博主"><a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>博主</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="阿旭"
      src="/images/touxiang.jpg">
  <p class="site-author-name" itemprop="name">阿旭</p>
  <div class="site-description" itemprop="description">软件开发学生党</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/aaaxu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aaaxu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/aaaxu" class="github-corner" title="My GitHub" aria-label="My GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.xulixuli.ltd/2021/04/20/spring-ioc%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpg">
      <meta itemprop="name" content="阿旭">
      <meta itemprop="description" content="软件开发学生党">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿旭的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring IOC:实现原理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-20 23:27:33" itemprop="dateCreated datePublished" datetime="2021-04-20T23:27:33+08:00">2021-04-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2021/04/20/spring-ioc%E5%8E%9F%E7%90%86/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2021/04/20/spring-ioc原理/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>简介：</strong>介绍Spring IOC 的实现原理以及IOC容器的启动流程。</p>
<p><strong>关键词：</strong>Spring IOC；IOC原理；IOC源码；IOC启动；</p>
<span id="more"></span>

<h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><p>在传统的 Java 应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 new Object() 的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。</p>
<p>但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC 容器手里的，其大致步骤如下。</p>
<ol>
<li>开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java 对象进行定义，例如在 XML 配置文件中使用 <bean> 标签、在 Java 类上使用 @Component 注解等。</li>
<li>Spring 启动时，IoC 容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC 容器创建并管理的对象被称为 Spring Bean。</li>
<li>当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过 ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 new Obejct() 的方式）创建。</li>
</ol>
<p>IoC 带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在 Spring 应用中，IoC 容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC 容器创建它所需要的对象（Bean）。</p>
<p>这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给 IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。</p>
<p>IOC有一个专门的容器来创建这些对象，由IOC容器来控制对象的创建，依赖对象也是容器帮忙查找创建并进行注入，对象只是被动的接受，依赖对象的获取被反转了。它还有一个更加形象的名字叫 依赖注入。</p>
<p><strong>依赖注入方式：</strong></p>
<ul>
<li>接口注入</li>
<li>setter</li>
<li>构造器注入</li>
</ul>
<p>IOC容器的设计与实现有两种：<strong>BeanFactory</strong>和<strong>ApplicationContext</strong>：</p>
<ul>
<li>实现了BeanFactory接口的简单容器系列，只是实现了容器最基本的功能。</li>
<li>Applic ationContext应用上下文，作为容器的高级形态存在。除了具有基本的功能外，还增加了许多面向框架的特性，同时对应用环境做了许多适配。</li>
</ul>
<h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>BeanFactory为IOC容器具体实现指定了基本的规范，它有三个子类，ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory接口。但是它们最终生成了一个默认的实现类DefaultListableBeanFactory。类的继承关系如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-40bdc919b96905bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/642/format/webp" alt="img"></p>
<p>BeanFactory接口中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过使用转义符“&amp;”，来区分BeanFactory产生的对象和BeanFactory本身</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    <span class="comment">//根据Bean的名字获取Bean的实例</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">//根据Bean的名字和Class类型来获取实例，增加了类型安全验证</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String var1, Class&lt;T&gt; var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">//根据Class类型来获取实例</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; var1)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">//返回实例</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String var1, Object... var2)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="comment">//是否包含指定的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String var1)</span></span>;</span><br><span class="line">    <span class="comment">//是否单例</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">//是否是原型</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String var1)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">//类型是否匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String var1, Class&lt;?&gt; var2)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">//返回指定实例名的类型</span></span><br><span class="line">    Class&lt;?&gt; getType(String var1) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    <span class="comment">//返回别名</span></span><br><span class="line">    String[] getAliases(String var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanFactory并不关心bean是如何定义、怎样被加载。当我们需要bean的时候，直接来取就可以了。对于工厂来说，我只需要关心有没有产品，对于产品是怎么产生，怎么制作的，那是工人干的事，工厂并不关心。定义的都是最核心的接口，如<code>getBean()</code>从容器中获取实例。</p>
<h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><strong>ApplicationContext</strong></h1><p>ApplicationContext是Spring提供的一个高级的IOC容器，与BeanFactory的区别是，BeanFactory提供了容器最基本的功能，而ApplicationContext除了提供基本IOC容器的功能外，还能为用户提供更丰富的功能：</p>
<ul>
<li>支持信息源，可以实现国际化</li>
<li>访问资源</li>
<li>支持应用事件</li>
<li>ApplicationContext中提供的附加服务</li>
</ul>
<p>可以认为ApplicationContext 是 BeanFactory的扩展，在使用时，我们往往是直接与ApplicationContext 打交道。</p>
<p><strong>ApplicationContext的继承关系：</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-fb440cb3f5b7a5ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1001/format/webp" alt="img"></p>
<ul>
<li><p>在BeanFactory中，从BeanFactory到HierarchicalBeanFactory,再到ConfigurableBeanFactory,是一个条主要的设计路径。 BeanFactory中定义了基本的IOC容器规范，在HierarchicalBeanFactory接口中增加了getparantBeanFactory()的接口功能，使BeanFactory具备了双亲IOC容器的管理功能，在ConfigurableBeanFactory主要定义了一些对BeanFactory的配置功能</p>
</li>
<li><p>在ApplicationContext中，从BeanFactory到ListableBeanFactory,再到ApplicationContext,再到常用的WebApplicationContext或者ConfigurableApplicationContext接口。在BeanFactory简单接口的基础上增加了对高级容器的特性支持。</p>
</li>
</ul>
<h1 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h1><p>SpringIOC容器帮我们管理了各种bean对象及其相互依赖的关系，依赖关系是使用BeanDefinition来保存的：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-f5913afea471c32c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512/format/webp" alt="img"></p>
<p>Spring关于Bean的装配，有下面三种方式：</p>
<ul>
<li>在XML中进行显示配置</li>
<li>在java中进行显示配置</li>
<li>隐式的bean发现机制和自动装配</li>
</ul>
<p>Bean的解析非常的复杂，功能被分的很细，需要扩展的地方也很多，必须保证有足够的灵活性，下面看一下基于xml配置文件解析的继承体系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-7cafa9f49fd0007e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/332/format/webp" alt="img"></p>
<h1 id="IOC容器的初始化"><a href="#IOC容器的初始化" class="headerlink" title="IOC容器的初始化"></a>IOC容器的初始化</h1><p>IOC容器的初始化包括：BeanDefinition的<strong>Resouce定位，BeanDefinition的载入和注册</strong>三个基本的过程。需要注意的是Spring把上面过程进行了分离，并使用了不同的模块来完成，定位使用了ResourceLoader,解析使用了BeanDefinitionReader等。这样设计的目的可以让用户对这三个过程进行裁剪和扩展，定义出适合自己的IOC容器初始化过程。</p>
<p>下面来看一下两种IOC容器的创建过程，BeanFactory以XmlBeanFactory为例，ApplicationContext 以 FileSystemXmlApplicationContext为例</p>
<h2 id="XmlBeanFactroy"><a href="#XmlBeanFactroy" class="headerlink" title="XmlBeanFactroy"></a>XmlBeanFactroy</h2><p>XmlBeanFactory的源码定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanFactory</span> <span class="keyword">extends</span> <span class="title">DefaultListableBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个BeanDefinitionReader阅读器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader;</span><br><span class="line">    <span class="comment">//构造方法，需要传入Resource，资源的定位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(resource, (BeanFactory)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造方法重载，需要传入Resource,和父容器，此方法完成了读取器的初始化操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">        <span class="keyword">this</span>.reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读XmlBeanFactory的源码可以看出，XmlBeanFactory继承自DefaultListableBeanFactory类。而DefaultListableBeanFactory类包含了基本IOC容器所具有的重要功能。那BeanDefinition的信息来源自哪,如何定位? 定位之后又如何读取解析呢？对于信息来源的定位封装成Spring中的Resource类来给出，解析是它的内部定义了一个XmlBeanDefinitionReader对象，有了这个对象，就有了处理xml文件的能力。参考XmlBeanFactory的实现，我们手动来模拟一下XmlBeanFactory的实现过程</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先进行BeanDefinition资源文件的定位，封装为Source的子类</span></span><br><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"><span class="comment">//创建基本的IOC容器</span></span><br><span class="line">DefaultListableBeanFactory <span class="keyword">factory</span> = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line"><span class="comment">//创建文件读取器，并进行回调设置。</span></span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">factory</span>);</span><br><span class="line"><span class="comment">//资源加载解析</span></span><br><span class="line">reader.loadBeanDefinitions(res);</span><br></pre></td></tr></table></figure>

<p>通过上面的代码，总结一下IOC容器的使用步骤：</p>
<ul>
<li>创建IOC抽象资源，这个抽象资源包含了BeanDefinition的定义信息</li>
<li>创建一个BeanFactory</li>
<li>创建一个BeanDefinition的读取器，通过一个回调配置给BeanFactory</li>
<li>从定义好的抽象资源中读取配置信息。完成载入和注册的定义后，IOC容器就建立了起来了。</li>
</ul>
<h2 id="FileSystemXmlApplicationContext"><a href="#FileSystemXmlApplicationContext" class="headerlink" title="FileSystemXmlApplicationContext"></a>FileSystemXmlApplicationContext</h2><p>先来看一下FileSystemXmlApplicationContext的继承关系：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2192701-b704c5641b36c6f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1066/format/webp" alt="img"></p>
<p>通过上面的继承关系，可以发现它的基类AbstractXmlApplicationContext中已经实现了主要的功能。</p>
<p>在看一下这个类的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造方法重载，省略其他的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过一个FileSystemResource来得到一个在文件系统中定位的BeanDefinition</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Resource <span class="title">getResourceByPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path != <span class="keyword">null</span> &amp;&amp; path.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">            path = path.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileSystemResource(path);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了构造方法和getResourceByPath外，并没有其他的方法。也就说它只是实现了和它自身设计相关的两个功能。该类的调用方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context =<span class="keyword">new</span> FileSystemXmlApplicationContext(xmlPath);</span><br></pre></td></tr></table></figure>

<p>上面调用了参数是字符串的构造函数,但是，对构造函数的调用最终都会转到下面的方法来执行，refresh方法启动了整个容器的初始化流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileSystemXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(parent);</span><br><span class="line">      <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">      <span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，super(parent)这个方法最终是由其基类（AbstractApplicationContext）来执行，执行了AbstractApplicationContext的无参构造方法和setParent(）方法。其代码如下，省略了静态代码块的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileSystemXmlApplicationContext调用父类构造方法就是该方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    setParent(parent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体需要执行的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.resourcePatternResolver = getResourcePatternResolver();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取一个Source的加载器用于读入Spring Bean 定义资源文件</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResourcePatternResolver <span class="title">getResourcePatternResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置双亲ioc容器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">        <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">            getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用父类的构造方法执行完成后，返回<code>FileSystemXmlApplicationContext</code>类，执行<code>setConfigLocations(configLocations)</code>方法，该方法的定义在类<code>AbstractRefreshableConfigApplicationContext</code>中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理资源定义的数组，解析Bean文件的定义路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span>(<span class="params">String[] locations</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (locations != <span class="literal">null</span>) &#123;</span><br><span class="line">            Assert.noNullElements(locations, <span class="string">&quot;Config locations must not be null&quot;</span>);</span><br><span class="line">            <span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line">                <span class="comment">//解析路径</span></span><br><span class="line">                <span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.configLocations = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p> 在资源定位的时候，支持下面两种方式：</p>
<ul>
<li>ClasspathResource res = new ClasspathResource(“a.xml,b.xml”);</li>
<li>ClasspathResource res = new ClasspathResource(“new String(){‘a.xml’ , ‘b.xml’}”)<br>具体实现的方式不在展开，感兴趣的可以去看一下源码实现</li>
</ul>
<p>我们来看以上，程序执行到此处后，都做了哪些操作：</p>
<ol>
<li>在AbstractApplicationContext中初始化了resourcePatternResolver（多资源文件的载入），用于获取Resource，关于何时使用后面再解释</li>
<li>将资源的定义路径保存在了configLocations数组中</li>
</ol>
<p>到此，IOC容器根据资源定义路径获取Resouce的准备工作便完成了。</p>
<h2 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h2><p>在开始分析初始化过程之前，先从宏观上对初始化的过程做一个简单的介绍，有一个大体框架的初始化模型，方便后面的理解，初始化过程分成了三个过程：</p>
<ul>
<li>Resource定位</li>
<li>BeanDefinition的载入</li>
<li>向IOC容器注册这些BeanDefinition信息。这个过程是通过BeanDefinitionRegistry接口的实现来完成的。最终注入到HashMap中去，这个hashmap就是持有beandefinition数据的。</li>
</ul>
<p>下面来看一下FileSystemXmlApplicationContext中的关于refresh()方法的调用，实际调用的是AbstractApplicationContext中的refresh()方法，该方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">//环境准备，获取容器启动的时间，设置活动标志，以及属性的初始化</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">//在子类中启动resreshBeanfactory()方法</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">//为BeanFactory配置容器属性</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置BeanFactory的后置处理</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">//调用后置处理，为这些后置处理器在Bean的定义中向容器注册</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">//注册Bean的后续处理，在Bean创建过程中调用</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">//初始化上下文消息机制</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">//初始化上下文中事件机制</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">//初始化其他特殊的Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">//检查监听Bean并且将这些Bean向容器注册</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">//初始化所有的singleton beans , 设置lazy-init = true 的bean除外</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">//发布容器事件，结束Refresh过程</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 为防止Bean资源占用，在异常处理中，销毁已经生成的单件Bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            <span class="comment">//重置Rest标志</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>refresh()</code>方法主要为IOC容器Bean的生命周期提供管理条件。Spring IOC容器的生成是从<code>refreshBeanFactory()</code>方法开始的，也就是执行了下面的代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用委派模式，父类只是定义了方法，具体实现交给子类</span></span><br><span class="line">        refreshBeanFactory();</span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在AbstractApplicationContext抽象类中，只是进行了<code>refreshBeanFactory()</code>方法的定义，方法的实现是在其子类AbstractRefreshableApplicationContext中实现的，在子类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123; <span class="comment">//如果已经有容器，则销毁并关闭容器</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建IOC容器</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">//对容器进行定制化，如设置启动参数，开启注解自动装配等</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">//委派模式，资源的加载交给子类实现，启动对BeanDefinition的载入操作</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码<code>loadBeanDefinitions(beanFactory);</code>我们说是一个委派模式，只是进行了方法的定义，具体实现则是由<code>AbstractXmlApplicationContext</code>类实现，在该方法中创建了读取器<code>XmlBeanDefinitionReader</code>的实例,然后把这个读取器在IOC容器中设置好，最后是启动读取器来完成对<code>BeanDefinition</code>在IOC容器中的载入，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建XmlBeanDefinitionReader</span></span><br><span class="line">    <span class="comment">//即创建Bean读取器，并通过回调设置到容器中去，容器使用该读取器，读取Bean定义资源</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    <span class="comment">//为Bean读取器设置资源加载器</span></span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//设置一个Sax实体用于解析</span></span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line">    <span class="comment">//当Bean读取器读取Bean定义的xml资源文件时，启用xml校验机制</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">//Bean 读取器真正的实现加载的方法</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>XmlBeanDefinitionReader</code>的初始化过程中，还进行了一些其他的操作，具体如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用父类的构造方法</span></span><br><span class="line"><span class="keyword">public</span> XmlBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    <span class="keyword">super</span>(registry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类构造方法</span></span><br><span class="line"><span class="keyword">protected</span> AbstractBeanDefinitionReader(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">this</span>.registry = registry;</span><br><span class="line">    <span class="comment">//判断register是否是ResourceLoader 类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registry instanceof ResourceLoader) &#123;</span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = (ResourceLoader) <span class="keyword">this</span>.registry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//为resourceLoader 新建一个资源加载器</span></span><br><span class="line">        <span class="keyword">this</span>.resourceLoader = new PathMatchingResourcePatternResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断register 是否是 EnvironmentCapable类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.registry instanceof EnvironmentCapable) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = ((EnvironmentCapable) <span class="keyword">this</span>.registry).getEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个environment </span></span><br><span class="line">        <span class="keyword">this</span>.environment = new StandardEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面代码发现，在创建XmlBeanDefinitionReader的过程中，完成了resourceLoader和eviironment的赋值操作。</p>
<p>首先得到BeanDefinition信息的Resource定位，然后直接调用XmlBeanDefinitionReader来读取，具体的载入过程是委托给BeanDefinitionReader来完成的。因为使用的FileSystemXmlApplicationContext, getConfigResources()方法返回的是null,所以程序会走第二个分支</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Xml Bean读取器加载Bean定义资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//获取资源定位</span></span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Xml Bean读取器调用其父类AbstractBeanDefinitionReader读取定位 </span></span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果子类获取的Bean定义为空，则获取FileSystemXmlApplication构造方法中setConfigLocations方法设置的资源。</span></span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinition(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序分析到这，来梳理一下上面的执行流程。</p>
<ul>
<li>在FileSystemXmlApplicationContext一共做了三件事<ul>
<li>调用了父类的构造器，进行了初始化</li>
<li>设置了BeanDefinition的定义路径</li>
<li>执行了Refresh()方法</li>
</ul>
</li>
<li>refresh()方法来启动整个BeanDefinition的载入过程<ul>
<li>创建容器 DefaultListableBeanFactory</li>
<li>创建了XmlXmlBeanDefinitionReader</li>
<li>开始准备通过reader来加载资源</li>
</ul>
</li>
</ul>
<p>AbstractBeanDefinitionReader读取Bean定义资源，AbstractBeanDefinitionReader的loadBeanDefinitions方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">&quot;Location array must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    String[] var3 = locations;</span><br><span class="line">    <span class="keyword">int</span> var4 = locations.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        String location = var3[var5];</span><br><span class="line">        counter += <span class="keyword">this</span>.loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(location, (Set)<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载的最终执行方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, Set&lt;Resource&gt; actualResources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">//获取资源加载器</span></span><br><span class="line">    <span class="comment">//上面提到过，XmlBeanDefinitionReader初始化时，在其父类中执行了加载器的初始化操作</span></span><br><span class="line">    <span class="comment">//resourceLoader的类型为PathMatchingResourcePatternResolver</span></span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Cannot import bean definitions from location [&quot;</span> + location + <span class="string">&quot;]: no ResourceLoader available&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断类型</span></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将指定位置的Bean定义资源文件解析转化为Resource</span></span><br><span class="line">            <span class="comment">//加载多个指定位置的资源定义文件</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);</span><br><span class="line">            <span class="comment">//读取Resource</span></span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Can only load single resources by absolute URL.</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Loaded &quot;</span> + loadCount + <span class="string">&quot; bean definitions from location [&quot;</span> + location + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        Assert.notNull(resources, <span class="string">&quot;Resource array must not be null&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        Resource[] var3 = resources;</span><br><span class="line">        <span class="keyword">int</span> var4 = resources.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            Resource resource = var3[var5];</span><br><span class="line">            counter += <span class="keyword">this</span>.loadBeanDefinitions((Resource)resource);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法主要进行了两件事：</p>
<ul>
<li>调用资源加载器获取资源 resourceLoader.getResource(location)</li>
<li>真正执行加载功能的是子类XmlBeanDefinitionReader的loadBeanDefinitions方法</li>
</ul>
<p>loadBeanDefinitions()方法在AbstractBeanDefinitionReader中并没有具体的实现，它会转到XmlBeanDefinitionReader中的loadBeanDefinitions(Resource resource)中运行：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">loadBeanDefinitions</span>(<span class="params">Resource resource</span>) throws BeanDefinitionStoreException</span> &#123;</span><br><span class="line">    <span class="comment">//对xml资源进行编码处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法重载，转入此方法执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">loadBeanDefinitions</span>(<span class="params">EncodedResource encodedResource</span>) throws BeanDefinitionStoreException</span> &#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line">    Object currentResources = (Set)<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">get</span>();</span><br><span class="line">    <span class="keyword">if</span>(currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">set</span>(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!((Set)currentResources).<span class="keyword">add</span>(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将资源文件转换为类型为InputStream的I/O流</span></span><br><span class="line">            InputStream ex = encodedResource.getResource().getInputStream();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从InputStream中得到xML的解析源</span></span><br><span class="line">                InputSource inputSource = <span class="keyword">new</span> InputSource(ex);</span><br><span class="line">                <span class="comment">//编码如果不为null, 则设置inputSource的编码</span></span><br><span class="line">                <span class="keyword">if</span>(encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//读取数据</span></span><br><span class="line">                var5 = <span class="keyword">this</span>.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ex.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException var15) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), var15);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ((Set)currentResources).<span class="keyword">remove</span>(encodedResource);</span><br><span class="line">            <span class="keyword">if</span>(((Set)currentResources).isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.<span class="keyword">remove</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="built_in">int</span> <span class="title">doLoadBeanDefinitions</span>(<span class="params">InputSource inputSource, Resource resource</span>)throws BeanDefinitionStoreException</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//转化为Document 对象</span></span><br><span class="line">            Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">            <span class="comment">//启动对Bean定义解析的详细过程，会用到Spring Bean的配置规则</span></span><br><span class="line">            <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除了部分catch语句</span></span><br><span class="line">        catch (....) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>将XML文件转换成Document对象，解析过程由documentLoader实现，getValidationModeForResource（resource）验证xml文件的模式 DTD还是XSD，此方法不在展开。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource,getEntityResolver(), <span class="keyword">this</span>.errorHandler,getValidationModeForResource(resource),isNamespaceAware());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>创建Document 的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Document <span class="title">loadDocument</span><span class="params">(InputSource inputSource, EntityResolver entityResolver,ErrorHandler errorHandler, <span class="keyword">int</span> validationMode, <span class="keyword">boolean</span> namespaceAware)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//创建文件解析工厂</span></span><br><span class="line">    DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Using JAXP provider [&quot;</span> + factory.getClass().getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建文档解析器</span></span><br><span class="line">    DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);</span><br><span class="line">    <span class="comment">//解析Spring bean定义资源 ，并返回Document对象</span></span><br><span class="line">    <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring并没有对XML进行特殊的处理，使用了SAX对xml文档进行解析，操作分为三步：</p>
<ul>
<li>创建DocumentBuilderFactory</li>
<li>创建DocumentBuilder</li>
<li>解析inputSource对象，返回Document 对象</li>
</ul>
<blockquote>
<p>Document对象代表了一个XML文档的模型树，所有的其他Node都以一定的顺序包含在Document对象之内，排列成一个树状结构，以后对XML文档的所有操作都与解析器无关，直接在这个对象上操作即可。NodeList代表了包含一个或者多个Node的列表，操作上可以看作数组，使用getLength()获得列表中的节点数，item(int index ) 返回集合中第index个项。Node对象很少使用，会使用它的自对象Element,Attr 等。</p>
</blockquote>
<p>至此，Spring IOC容器根据定位的Bean定义资源文件，并将其加载读入转换为document对象的过程完成。</p>
<p>上面略微呢有一点跑题，document对象的创建过程可能不是我们最关心的，我们关心就是Spring的BeanDefinition是怎样按照Spring的Bean语义要求进行解析并转化为容器内部数据结构的。 这个过程是在下面的方法中执行的，我们来看一下，具体的操作过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">//创建DocumentReader来对XML格式的BeanDefinition进行解析    </span></span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="comment">//获得容器中已经存在的Bean数量</span></span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">//具体的解析过程在这个方法中执行</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bean定义资源的解析分为以下两个过程：</p>
<ul>
<li>通过调用xml解析器，将资源定义文件转换为Document对象，document对应并没有按照spring bean的规则进行解析。</li>
<li>在完成通用xml解析之后，按照Spring的Bean规则对Document对象进行解析，这个过程是在documentReader中实现的。具体的操作是由DefaultBeanDefinitionDocumentReader完成的。<br> 处理的结果由BeanDefinitionHolder对象持有。解析过程由BeanDefinitionParserDelegate来实现。</li>
</ul>
<p>来看下面的流程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据Spring DTD 对bean定义的规则解析Bean定义Document对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span>(<span class="params">Document doc, XmlReaderContext readerContext</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//获取xml描述符</span></span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    logger.debug(<span class="string">&quot;Loading bean definitions&quot;</span>);</span><br><span class="line">    <span class="comment">//获得Document的根对象</span></span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span>(<span class="params">Element root</span>)</span> &#123;</span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.<span class="built_in">delegate</span>;</span><br><span class="line">    <span class="comment">//BeanDefinitionParserDelegate中定义了Spring Bean定义的XML文件的各种元素</span></span><br><span class="line">    <span class="comment">//默认BeanDefinitionParserDelegate会处理”http://www.springframework.org/schema/beans“命名空间下元素及其属性</span></span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">delegate</span> = createDelegate(getReaderContext(), root, parent);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.<span class="built_in">delegate</span>.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">//对于默认的命名空间，首先开始的是对profile属性解析</span></span><br><span class="line">        <span class="comment">//profile用得最多的是DataSource在不同环境下使用不同的bean</span></span><br><span class="line">        <span class="comment">//spring使用StringTokenizer来进行字符串的分割，但是jdk为了兼容性是推荐使用String.split()方法的：</span></span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来的解析使用了模板模式</span></span><br><span class="line">    <span class="comment">//进行自定义的解析，增强解析过程的可扩展性 ，空实现</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">//从Document的根元素开始进行Bean定义的document对象</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.<span class="built_in">delegate</span>);</span><br><span class="line">    <span class="comment">//在解析Bean定义之后，进行自定义的解析，增加解析过程的可扩展性。空实现</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line">    <span class="keyword">this</span>.<span class="built_in">delegate</span> = parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanDefinitionParserDelegate <span class="title">createDelegate</span>(<span class="params">XmlReaderContext readerContext, Element root, BeanDefinitionParserDelegate parentDelegate</span>)</span> &#123;</span><br><span class="line">    BeanDefinitionParserDelegate <span class="built_in">delegate</span> = <span class="keyword">new</span> BeanDefinitionParserDelegate(readerContext);</span><br><span class="line">    <span class="built_in">delegate</span>.initDefaults(root, parentDelegate);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">delegate</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析document文件，不同的命名的空间采用不同的方法处理</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span>(<span class="params">Element root,BeanDefinitionParserDelegate <span class="built_in">delegate</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//Bean定义的Document对象使用了Spring默认的XML命名空间</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">delegate</span>.isDefaultNamespace(root)) &#123;</span><br><span class="line">        <span class="comment">//获取Document对象的所有子节点，NodeList的含义上面进行了介绍</span></span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);  <span class="comment">//获取Node节点</span></span><br><span class="line">            <span class="comment">//判断Node是否是Element类型</span></span><br><span class="line">            <span class="keyword">if</span> (node instanceof Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="comment">//判断该元素是否属于Spring定义Bean的默认命名空间</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">delegate</span>.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">//使用Spring的Bean规则解析元素节点</span></span><br><span class="line">                    parseDefaultElement(ele, <span class="built_in">delegate</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使用用户自定义的规则进行解析</span></span><br><span class="line">                    <span class="built_in">delegate</span>.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没有使用spring默认的命名空间，则使用用户自定义的解析规则解析</span></span><br><span class="line">        <span class="built_in">delegate</span>.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用spring的Bean规则解析Document元素节点，有些元素节点是<import> <bean> 等，则分别进行解析</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span>(<span class="params">Element ele, BeanDefinitionParserDelegate <span class="built_in">delegate</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//如果元素节点是&lt;Import&gt;导入元素，进行导入解析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">delegate</span>.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果元素节点是&lt;Alias&gt;别名元素，进行别名解析</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">delegate</span>.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是&lt;bean&gt;转入此流程处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">delegate</span>.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        processBeanDefinition(ele, <span class="built_in">delegate</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是&lt;beans&gt;转入此流程处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">delegate</span>.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">            <span class="comment">// recurse</span></span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要看一下对bean标签的解析过程。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span>(<span class="params">Element ele,BeanDefinitionParserDelegate <span class="built_in">delegate</span></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//BeanDefinitionHolder是对BeanDefinition的封装，delegate解析完成后使用holder封装,bdHolder 包含了id ,别名和BeanDefinition的信息</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = <span class="built_in">delegate</span>.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="literal">null</span>) &#123;</span><br><span class="line">        bdHolder = <span class="built_in">delegate</span>.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向容器注册封装后的实例</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在Beandefinition向IoC容器注册完成以后，发送消息</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下parseBeanDefinitionElement（）方法的具体实现,对于BeanDefinition的注册时存放在ConcurrentHashMap中的，beanName变为存放的健：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public BeanDefinitionHolder parseBeanDefinitionElement(<span class="built_in">Element</span> ele, BeanDefinition containingBean) &#123;</span><br><span class="line">    <span class="comment">//获取id的值</span></span><br><span class="line">    <span class="built_in">String</span> id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    <span class="comment">//获取name的值</span></span><br><span class="line">    <span class="built_in">String</span> nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">    <span class="comment">//分割name属性</span></span><br><span class="line">    <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; aliases = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        <span class="built_in">String</span>[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将id赋值给beanName </span></span><br><span class="line">    <span class="built_in">String</span> beanName = id;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该方法引发对Bean元素的详细解析</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    <span class="comment">//程序执行到此处，整个&lt;bean&gt;标签的解析就算结束了。一个beanDefinition就创建好了</span></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果不存在beanName,那么根据Spring中的提供的命名规则为当前bean生成对应的beanName</span></span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    <span class="built_in">String</span> beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    error(ex.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">String</span>[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="comment">//将信息封装到BeanDefinitionHolder中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition可以看成是对<bean>定义的抽象，这个数据对象中封装的数据大多都是与<bean>定义相关的，也有很多就是我们在定义Bean时看到的那些Spring标记。这个BeanDefinition数据类型是非常重要的，它封装了很多基本数据，这些都是Ioc容器需要的，上面代码最后我们返回了一个BeanDefinitionHolder实例，这个实例封装了beanDefinition,beanName, aliase三个信息，beanDefinition中也包含了beanName,aliase信息。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.parseState.push(new BeanEntry(beanName));</span><br><span class="line">    <span class="comment">//这里只读取定义的&lt;bean&gt;中设置的class名字，然后载入到BeanDefinition中去，只是做个记录，并不涉及对象的实例化过程，对象的实例化过程实际是在依赖注入时完成的</span></span><br><span class="line">    String className = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//解析parent属性</span></span><br><span class="line">        String parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">            parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建用于承载属性的AbstractBeanDefinition类型的GenereicBeanDefinition</span></span><br><span class="line">        <span class="comment">//这里生成需要的BeanDefinition对象，为Bean定义的信息做载入做准备</span></span><br><span class="line">        AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line">        <span class="comment">//这里对当前Bean元素进行属性解析，并设置description信息</span></span><br><span class="line">        parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">        bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">        <span class="comment">//解析元数据</span></span><br><span class="line">        parseMetaElements(ele, bd);</span><br><span class="line">        <span class="comment">//解析lookup-method属性</span></span><br><span class="line">        parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">//解析replaced-method属性</span></span><br><span class="line">        parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">        <span class="comment">//解析构造函数参数</span></span><br><span class="line">        parseConstructorArgElements(ele, bd);</span><br><span class="line">        <span class="comment">//解析property子元素</span></span><br><span class="line">        parsePropertyElements(ele, bd);</span><br><span class="line">        <span class="comment">//解析qualifier子元素</span></span><br><span class="line">        parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">        bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">        bd.setSource(extractSource(ele));</span><br><span class="line">        <span class="comment">//返回BeanDefinition对象</span></span><br><span class="line">        <span class="keyword">return</span> bd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，要解析属性首先要创建用于承载属性的实例，也就是创建GenericBeanDefinition类型的实例，而代码createBeanDefinition(className,parent)的作用就是实现此功能。创建完承接的实例后，便可以进行各种属性的解析了，首先进行解析的是在<bean></bean>标签中定义的各种属性，如scope, singleton,abstract,lazy-init等，然后再解析子标签中的属性，如：lookup-method ,constructor-arg等。解析完成之后关联到实例上，之所以能进行关联，是因为xml中所有的配置都能在GenericBeanDefinition的实力类中找到对应的配置。 此时容器还没有起作用，要想起作用，需要向容器进行注册。</p>
<p>分析到这，已经完成了xml文件向BeanDefinition的转化，每个一个<bean>标签都会转化成一个BeanDefinition对应的实体。实体中包含了<bean>中定义的所有属性。</p>
<h2 id="BeanDefinition在IOC容器中的注册"><a href="#BeanDefinition在IOC容器中的注册" class="headerlink" title="BeanDefinition在IOC容器中的注册"></a>BeanDefinition在IOC容器中的注册</h2><p>前面只是进行了BeanDefinition在IOC容器中的载入和解析过程，这些动作完成后，已经完成了定义的数据转化为BeanDefinition的过程。下面代码继续执行，看一下注册的过程，也就是processBeanDefinition函数中的BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,getReaderContext().getRegistry())的代码。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//registerBeanDefinition()方法的具体实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span>(<span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry</span>)throws BeanDefinitionStoreException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取beanName</span></span><br><span class="line">    String beanName = definitionHolder.getBeanName();</span><br><span class="line">    <span class="comment">//使用beanName作为唯一标识注册</span></span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果解析的BeanDefinition有别名，也要根据别名在注册一遍，不然根据别名找不到相应的信息</span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String <span class="keyword">alias</span> : aliases) &#123;</span><br><span class="line">            <span class="comment">//beanName -&gt; alias ,先将alias转换为beanName,在查找</span></span><br><span class="line">            registry.registerAlias(beanName, <span class="keyword">alias</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终承接注册任务方法是在DefaultListableBeanFactory类中定义的，为了更好的排版，我对下面的代码进行了删减，主要删除了抛出异常信息和日志信息，并不影响代码的逻辑，对于beanDefinition的注册，做了一些验证之后，直接将beanDefinition放入了Map中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//向IoC容器注册解析的BeanDefiniton </span></span><br><span class="line"><span class="keyword">public</span> void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)throws BeanDefinitionStoreException &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (beanDefinition instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//注册前的最后一次校验</span></span><br><span class="line">            <span class="comment">//主要是对AbstractBeanDefinition属性中的methodOverrides校验</span></span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition oldBeanDefinition;</span><br><span class="line">    <span class="comment">//检查是否有同名的beanName存在，判断allowBeanDefinitionOveriding属性</span></span><br><span class="line">    oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.<span class="keyword">get</span>(beanName);</span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">                <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.warn(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.info(<span class="string">&quot;....&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果允许覆盖则执行覆盖操作</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否已经有其他的Bean开始初始化</span></span><br><span class="line">            <span class="comment">//在容器启动的最后会预初始化所有的singleton beans</span></span><br><span class="line">            <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">                <span class="comment">//注册的过程中需要线程同步，以保证数据的一致性 </span></span><br><span class="line">                synchronized (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                    <span class="comment">//注册</span></span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                    List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                    updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                    updatedDefinitions.add(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                        Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                        updatedSingletons.remove(beanName);</span><br><span class="line">                        <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//正常情况下应该走此分支</span></span><br><span class="line">                <span class="comment">//将BeanDefinition放入Map中，此map中保存了所有的BeanDefinition</span></span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                <span class="comment">//这个ArrayList中会按照bean配置的顺序保存每一个注册的Bean的名字</span></span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">                <span class="comment">//手动注册singleton bean </span></span><br><span class="line">                <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldBeanDefinition != <span class="literal">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">            resetBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，Bean定义资源文件中配置的Bean被解析过后，已经注册到IoC容器中，被容器管理起来，真正完成了IoC容器初始化所做的全部工作。现  在IoC容器中已经建立了整个Bean的配置信息，这些BeanDefinition信息已经可以使用，并且可以被检索，IoC容器的作用就是对这些注册的Bean定义信息进行处理和维护。这些的注册的Bean定义信息是IoC容器控制反转的基础，正是有了这些注册的数据，容器才可以进行依赖注入。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>执行完上面的操作后，IOC容器已经实现了对Bean管理定义的相关数据，但是此时IOC容器还没有对所管理的Bean进行依赖注入，依赖注入在以下两种情况下发生：</p>
<ul>
<li>用户第一次通过getBean()方法想容器索取时，进行依赖注入</li>
<li>当用户在Bean的定义中为<bean>配置了lazy-init属性，让容器在解析注册时进行欲初始化，触发依赖注入</li>
</ul>
<p>AbstactBeanFactory 通过getBean()函数获取被管理的Bean，但是因为lazyinit默认为false,所以spring会进行部分实例的初始化操作，让我们回退到AbstactApplicationContext类的finishBeanFactoryInitialization(beanFactory)方法，该方法进行了所有单例类的初始化操作，初始化的动作包装在了getBean()方法中，这个方法是获取Bean的地方，也是依赖注入发生的地方,对genBean的调用会转入到doGetBean()方法来执行,来看一下该方法的定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据执行的名称获取容器管理的Bean，已经初始化就直接返回，否则就先初始化在返回</span></span><br><span class="line">protected &lt;T&gt; T doGetBean(<span class="keyword">final</span> <span class="built_in">String</span> name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> <span class="built_in">Object</span>[] args, boolean typeCheckOnly)throws BeansException &#123;</span><br><span class="line">    <span class="comment">//提取定义的beanName，如果是别名，则将别名转换成规范的BeanName</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">//定义Bean</span></span><br><span class="line">    <span class="built_in">Object</span> bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查缓存中或者实例工厂中是否有对应的实例,单例模式的bean只创建一次</span></span><br><span class="line">    <span class="built_in">Object</span> sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="comment">//如果实例已经创建，进入if分支 ，简单介绍一下参数args，一般情况下args为null,如果args不为null,则不是为了得到bean，而是为了创建bean</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回对应的实例，getObjectForBeanInstance完成的是FactoryBean的相关处理，已取得FactoryBean的生产结果，此处是FactoryBean和BeanFactory有区别。一个是创建工厂，一个是管理Bean工厂不一样。</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//只有在单例情况下才会尝试解决循环依赖的问题，所谓循环依赖，是指：A中有B,B中有A , 形成了互相的引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 缓存中有指定名字的Bean但是由于循环引用创建失败了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查一下这个BeanDefinition在容器中是否存在</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">//如果当前容器不存在这个BeanDefinition,检查父容器中是否存在</span></span><br><span class="line">            <span class="built_in">String</span> nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//返回父容器的查询结果</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//委派父级容器进行查找</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不仅仅是做类型检查， 这里要进行记录</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="comment">//向容器标记指定的Bean已经被创建</span></span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行到这，需要创建新的Bean了。无论是单例还是原型。根据名字获取Beandefinition</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//先初始化所有的依赖bean</span></span><br><span class="line">            <span class="comment">//注意这里的依赖是指定义在depends-on中的依赖</span></span><br><span class="line">            <span class="built_in">String</span>[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">String</span> dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">//检查一下循环依赖</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(。。。);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//注册依赖关系</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="comment">//先初始化依赖项</span></span><br><span class="line">                    getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建单例模式Bean实例</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">//使用了匿名内部类，创建Bean实例对象，并且注册给所依赖的对象</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    public <span class="built_in">Object</span> getObject() throws BeansException &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//创建bean，如果有父级继承，则合并子类和父类的定义</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            <span class="comment">//销毁单例beanName对象实例</span></span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//获取给定beanName的实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建prototype的实例</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">//原型模式每次都会创建一个新的对象</span></span><br><span class="line">                <span class="built_in">Object</span> prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//回调beforPrototypeCreateion方法，默认的功能是注册当前创建的原型对象</span></span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">//创建实例</span></span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//回调afterPrototypeCreation方法，默认的功能告诉IOC容器指定bean的原型对象不在创建了</span></span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取给定的beanName实例对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是单例或者原型的话，则委托给响应的实现类来处理，例如request ,session , application等生命周期</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">String</span> scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.<span class="keyword">get</span>(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//使用匿名内部类获取一个指定生命周期范围的实例</span></span><br><span class="line">                    <span class="built_in">Object</span> scopedInstance = scope.<span class="keyword">get</span>(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    public <span class="built_in">Object</span> getObject() throws BeansException &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">//获取给定Bean的实力对象</span></span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(...);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后检查一下类型对不对，不对的话就抛出异常，对的话就返回</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(....);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将bean返回，此时的bean已经包含了依赖关系</span></span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK,上面的流程走完了，接下来该分析分支方法了， 没错，就是那个方法crateBean(),其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        RootBeanDefinition mbdToUse &#x3D; mbd;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;确保BeanDefinition中的class被加载</span><br><span class="line">        Class&lt;?&gt; resolvedClass &#x3D; resolveBeanClass(mbd, beanName);</span><br><span class="line">        if (resolvedClass !&#x3D; null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() !&#x3D; null) &#123;</span><br><span class="line">            mbdToUse &#x3D; new RootBeanDefinition(mbd);</span><br><span class="line">            mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;准备方法覆写,涉及到一个概念：MethodOverrides,来自于Bean定义的&lt;lookup-method&gt;和&lt;replaced-method&gt;。感兴趣的自行研究</span><br><span class="line">        try &#123;</span><br><span class="line">            mbdToUse.prepareMethodOverrides();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                    beanName, &quot;Validation of method overrides failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;让BeanPostProcessors 有机会返回一个代理实例而不是bean实例</span><br><span class="line">            &#x2F;&#x2F;要彻底了解清楚这个，需要看InstantiationAwwareBeanPostProcessor接口</span><br><span class="line">            Object bean &#x3D; resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">            if (bean !&#x3D; null) &#123;</span><br><span class="line">                return bean;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Throwable ex) &#123;</span><br><span class="line">            throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                    &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;核心方法，创建bean</span><br><span class="line">        Object beanInstance &#x3D; doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;Finished creating instance of bean &#39;&quot; + beanName + &quot;&#39;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return beanInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续来看 doCreateBean（）方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="built_in">Object</span> doCreateBean(<span class="keyword">final</span> <span class="built_in">String</span> beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="built_in">Object</span>[] args)throws BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个BeanWrapper是用来持有创建出来的Bean对象的</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        <span class="comment">//如果是singleton,先把缓存中的同名Bean清除</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//创建Bean的地方，由crateBeanInstance完成</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个就是Bean里面定义的类的实例</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object</span> bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>)：</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    synchronized (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">//解决循环依赖问题</span></span><br><span class="line">    boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                    <span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;<span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public <span class="built_in">Object</span> getObject() throws BeansException &#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    <span class="built_in">Object</span> exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//负责装配属性，给属性赋值</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  处理初始化后的各种回调</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="built_in">Object</span> earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="built_in">String</span>[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;<span class="built_in">String</span>&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">String</span> dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(。。。);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(。。。);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，doCreateBean方法便执行完了，上面的方法主要执行了三个步骤：</p>
<ul>
<li>创建Bean实例createBeanInstance方法</li>
<li>依赖注入populateBean方法</li>
<li>回调方法initializeBean</li>
</ul>
<p>下面介绍与依赖注入关系特别密切的方法createBeanInstance和populateBean方法。这个方法的主要作用就是实例化我们指定的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//确保已经加载了此class</span></span><br><span class="line">        Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">        <span class="comment">//校验这个类的访问权限</span></span><br><span class="line">        <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(....);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">            <span class="comment">//采用工厂方法实例化</span></span><br><span class="line">            <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用构造函数实例化</span></span><br><span class="line">        <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    resolved = <span class="keyword">true</span>;</span><br><span class="line">                    autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">            <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">                <span class="comment">//构造函数注入</span></span><br><span class="line">                <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//无参构造函数</span></span><br><span class="line">                <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否采用有参构造函数</span></span><br><span class="line">        Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">        <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">            <span class="comment">//构造函数依赖注入</span></span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用无参构造函数</span></span><br><span class="line">        <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在创建实例时，重要的是下面代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, <span class="built_in">parent</span>);</span><br></pre></td></tr></table></figure>

<p>继续跟进一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Don&#x27;t override the class with CGLIB if no overrides.</span></span><br><span class="line">        <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">            Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">            <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">                constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">                <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                    <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;Specified class is an interface&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                    <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            constructorToUse =  clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">&quot;No default constructor found&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">            <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>判断一下是否存在方法覆写，如果不存在就使用java反射的方式创建实例，否则使用CGLIB来创建实例。</p>
<p>在这简单说一下，spring创建Bean的两种方式，一种是通过BeanUtis（JVM的反射功能，必须要基于接口才能实现），另一种就是CGLIB来生成。具体的不做深入分析，会放入AOP中来说明。到这实例的创建就完成了， 下面说一下属性的注入.</p>
<p>bean 属性注入，上面的代码已经完成了Bean对象的实例化，实例化对象已经生成，怎样把这些Bean对象的依赖关系处理好，依赖关系已经保存在了BeanDefinition中，看下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//获取property的值。来自于BeanDefinition中。</span></span><br><span class="line">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">   <span class="comment">//判断实例是否为空</span></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//实例为空，属性不为空，抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(。。。);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span></span><br><span class="line">   <span class="comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//开始进行依赖注入过程，先处理autowire的注入</span></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 通过类型装配。复杂一些</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">               <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span></span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>initializeBean属性注入完成后，这一步其实就是处理各种回调了。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">protected <span class="built_in">Object</span> initializeBean(<span class="keyword">final</span> <span class="built_in">String</span> beanName, <span class="keyword">final</span> <span class="built_in">Object</span> bean, RootBeanDefinition mbd) &#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;<span class="built_in">Object</span>&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         public <span class="built_in">Object</span> run() &#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">Object</span> wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">      <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>转载自-<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c781f264467">简书</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/spring/" rel="tag"><i class="fa fa-tag"></i> spring</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/05/03/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E5%B7%A5%E5%85%B7/" rel="prev" title="实现硬盘排序-N路归并排序">
                  <i class="fa fa-chevron-left"></i> 实现硬盘排序-N路归并排序
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/03/10/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/" rel="next" title="Java虚拟机内存布局">
                  Java虚拟机内存布局 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">冀ICP备2021002135号-1 </a>
  </div>

<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">阿旭</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <script>
  NexT.utils.loadComments('#SOHUCS', () => {
    NexT.utils.getScript('https://changyan.sohu.com/upload/changyan.js', () => {
      window.changyan.api.config({
        appid: 'cyvxm2pbi',
        conf : 'prod_739bcda75a20596e51a2964edde3b31b'
      });
    });
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

</body>
</html>
